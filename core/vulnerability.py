"""
Vulnerability Models - Pydantic models for structured vulnerability data.

Adapted from SeCoRA with additional fields for ADK agent integration.
"""

from enum import Enum
from typing import List, Optional, Dict, Any
from datetime import datetime
from pydantic import BaseModel, Field
import uuid


class VulnerabilitySeverity(str, Enum):
    """Severity levels for vulnerabilities."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityType(str, Enum):
    """Common vulnerability types based on OWASP/CWE."""
    SQL_INJECTION = "SQL_INJECTION"
    CROSS_SITE_SCRIPTING = "CROSS_SITE_SCRIPTING"
    BROKEN_AUTHENTICATION = "BROKEN_AUTHENTICATION"
    SENSITIVE_DATA_EXPOSURE = "SENSITIVE_DATA_EXPOSURE"
    BROKEN_ACCESS_CONTROL = "BROKEN_ACCESS_CONTROL"
    SECURITY_MISCONFIGURATION = "SECURITY_MISCONFIGURATION"
    INSECURE_DESERIALIZATION = "INSECURE_DESERIALIZATION"
    VULNERABLE_COMPONENTS = "VULNERABLE_COMPONENTS"
    INSUFFICIENT_LOGGING = "INSUFFICIENT_LOGGING"
    SSRF = "SSRF"
    PATH_TRAVERSAL = "PATH_TRAVERSAL"
    CODE_INJECTION = "CODE_INJECTION"
    OS_COMMAND_INJECTION = "OS_COMMAND_INJECTION"
    REMOTE_CODE_EXECUTION = "REMOTE_CODE_EXECUTION"
    CSRF = "CSRF"
    HARDCODED_CREDENTIALS = "HARDCODED_CREDENTIALS"
    INSECURE_DIRECT_OBJECT_REFERENCE = "INSECURE_DIRECT_OBJECT_REFERENCE"
    FILE_INCLUSION = "FILE_INCLUSION"
    INFORMATION_DISCLOSURE = "INFORMATION_DISCLOSURE"
    UNKNOWN = "UNKNOWN"


class CodeLocation(BaseModel):
    """Location of code in a file."""
    file_path: str = Field(description="Path to the file")
    start_line: int = Field(description="Starting line number")
    end_line: int = Field(description="Ending line number")
    start_col: int = Field(default=0, description="Starting column")
    end_col: int = Field(default=0, description="Ending column")
    context: str = Field(default="", description="Code context/snippet")


class Vulnerability(BaseModel):
    """A detected security vulnerability."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type: VulnerabilityType = Field(description="Type of vulnerability")
    severity: VulnerabilitySeverity = Field(description="Severity level")
    location: CodeLocation = Field(description="Where the vulnerability was found")
    description: str = Field(description="Description of the vulnerability")
    impact: str = Field(description="Potential impact if exploited")
    remediation: str = Field(description="How to fix the vulnerability")
    cwe_id: str = Field(default="", description="CWE identifier")
    owasp_category: str = Field(default="", description="OWASP category")
    cvss_score: float = Field(default=0.0, description="CVSS score (0-10)")
    confidence: float = Field(default=0.8, description="Detection confidence (0-1)")
    references: List[str] = Field(default_factory=list, description="Reference links")
    detected_by: str = Field(default="", description="Agent/tool that detected this")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return self.model_dump()


class VulnerabilityChain(BaseModel):
    """A chain of related vulnerabilities that could be exploited together."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    vulnerabilities: List[Vulnerability] = Field(description="Chained vulnerabilities")
    combined_severity: VulnerabilitySeverity = Field(description="Combined severity")
    attack_path: str = Field(description="Description of the attack path")
    likelihood: float = Field(description="Likelihood of successful exploitation")
    prerequisites: List[str] = Field(default_factory=list)
    mitigation_priority: int = Field(default=1, description="Priority for mitigation (1-5)")


class VulnerabilityReport(BaseModel):
    """A complete vulnerability report from a scan."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=datetime.now)
    file_name: Optional[str] = None
    repository_url: Optional[str] = None
    branch: Optional[str] = None
    vulnerabilities: List[Vulnerability] = Field(default_factory=list)
    chained_vulnerabilities: List[VulnerabilityChain] = Field(default_factory=list)
    summary: Optional[Dict[str, int]] = None
    risk_score: float = Field(default=0.0)
    scan_duration_seconds: float = Field(default=0.0)
    agent_name: str = Field(default="", description="Name of the scanning agent")
    
    def calculate_summary(self):
        """Calculate vulnerability count by severity."""
        self.summary = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0,
            "total": len(self.vulnerabilities)
        }
        for vuln in self.vulnerabilities:
            self.summary[vuln.severity.value] += 1
    
    def calculate_risk_score(self):
        """Calculate overall risk score (0-100)."""
        if not self.vulnerabilities:
            self.risk_score = 0.0
            return
        
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10,
            VulnerabilitySeverity.HIGH: 7,
            VulnerabilitySeverity.MEDIUM: 4,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 0.5,
        }
        
        total_weight = sum(
            severity_weights[v.severity] * v.confidence 
            for v in self.vulnerabilities
        )
        
        # Normalize to 0-100 scale
        self.risk_score = min(100, total_weight)


# ===== Test Intelligence Models =====

class TestImpactPrediction(BaseModel):
    """Prediction of which tests are impacted by code changes."""
    changed_files: List[str] = Field(description="Files that were changed")
    impacted_tests: List[str] = Field(description="Tests predicted to be impacted")
    confidence_scores: Dict[str, float] = Field(
        default_factory=dict, 
        description="Confidence score for each test"
    )
    skip_tests: List[str] = Field(
        default_factory=list, 
        description="Tests that can safely be skipped"
    )
    total_tests: int = Field(default=0)
    predicted_runtime_savings: float = Field(default=0.0, description="Estimated time saved in seconds")


class FlakyTestResult(BaseModel):
    """Result of flaky test analysis."""
    test_id: str = Field(description="Test identifier")
    test_name: str = Field(description="Full test name")
    failure_probability: float = Field(description="P(failure) from Bayesian model")
    is_flaky: bool = Field(description="Whether test is classified as flaky")
    classification: str = Field(description="'flaky', 'regression', or 'unknown'")
    confidence: float = Field(description="Classification confidence")
    log_analysis: str = Field(default="", description="LLM analysis of logs")
    similar_failures: List[str] = Field(default_factory=list, description="IDs of similar past failures")
    recommended_action: str = Field(description="'quarantine', 'investigate', 'pass'")
    auto_quarantine: bool = Field(default=False)


class CoverageReport(BaseModel):
    """Test coverage analysis report."""
    total_lines: int = Field(default=0)
    covered_lines: int = Field(default=0)
    coverage_percentage: float = Field(default=0.0)
    uncovered_files: List[str] = Field(default_factory=list)
    low_coverage_functions: List[Dict[str, Any]] = Field(default_factory=list)
    recommendations: List[str] = Field(default_factory=list)
